import pymoos
import numpy as np
import utils
from AlgorithmDevelopment import generate_assignments
from AlgorithmDevelopment import missionLayouts as ml
import time
import sys

from Points import Points


# from py.AlgorithmDevelopment.cyclicRegionGrowth import gcd_of_list


# Class to handle MOOS communication and hold available vehicles and survey area.
class MOOSHandler:

    def __init__(self, host, port, client_name, time_warp):
        self.filled_cells = set()
        self.grid_data = None
        self.grid_width = None
        self.grid_height = None
        self.comms = pymoos.comms()
        self.host = host
        self.port = port
        self.client_name = client_name
        self.time_warp = time_warp
        self.survey_area = None  # Will be set by MOOSMsg sent by user
        self.survey_area_land = None  # Will be set by MOOSMsg sent by user
        self.available_vehicles = {}  # Will be generated by NODE_REPORTs sent by vehicles
        self.vehicles_turn = False  # True when UUVs return, false when vehicles return and at start
        self.available_uavs = {}
        self.sensor_ranges = []
        self.gcd = 1
        self.completed_uavs = {}
        self.completed_uuvs = {}
        self.gridMSG = " "
        self.position = " "
        self.bottomRight = " "
        self.topRight = " "
        self.topLeft = " "
        self.x, self.y = 0, 0
        self.x_edge = 0
        self.y_edge = 0

    def connect(self):
        # Start connection to MOOSDB and set callback
        pymoos.set_moos_timewarp(self.time_warp)
        # pymoos.set_moos_timewarp(5)
        self.comms.set_on_connect_callback(self.__on_connect)
        self.comms.run(self.host, self.port, self.client_name)
        self.comms.set_comms_tick(20)

    def __on_connect(self):
        # Runs after connection
        print("Connected to the MOOSDB")
        self.comms.notify("DEPLOY", "true", pymoos.time())
        self.survey_area = None
        self.available_vehicles = {}
        self.available_uavs = {}
        self.register_variables()
        self.comms.notify("MOOS_MANUAL_OVERRIDE", "false")
        self.comms.notify("RETURN", "false")
        return True

    def register_variables(self):
        # Register for necessary variables
        self.comms.register("NODE_REPORT")  # Needed for current position for each vehicle
        self.comms.register("SURVEY_AREA")  # Sent by a user to define area for vehicles to survey
        self.comms.register("HARMONY_REPORT")  # Sent by user
        self.comms.register("STATUS")

    def fetch_messages(self):
        # Will return a list of MOOS msg
        return self.comms.fetch()

    def notify(self, variable, value):
        # Send a message to MOOSDB
        self.comms.notify(variable, value, pymoos.time())

    def parse_incoming_messages(self, messages):
        # Input:
        #   A list of MOOS msgs. Usually produced by a fetch.
        #   List of available vehicles.
        #   Survey area
        # Output:
        #   Returns survey area
        #   Adds new vehicles to available vehicles based on NODE_REPORT
        for msg in messages:
            match msg.key():
                case "HARMONY_REPORT":
                    vehicle = utils.parseHarmonyReportAndCreateVehicle(msg.string())
                    if vehicle.type == 'UUV':
                        if vehicle and vehicle.name not in self.available_vehicles:
                            self.available_vehicles[vehicle.name] = vehicle
                            print("Added UUV:", vehicle)
                        if vehicle.sensorRange not in self.sensor_ranges:
                            self.sensor_ranges.append(int(vehicle.sensorRange))
                    if vehicle.type == 'glider':
                        if vehicle and vehicle.name not in self.available_uavs:
                            self.available_uavs[vehicle.name] = vehicle
                            print("Added UAVs:", vehicle)
                        if vehicle.sensorRange not in self.sensor_ranges:
                            self.sensor_ranges.append(int(vehicle.sensorRange))

                    # TO-DO: SET UAVS AND UUVS TO SEPARATE LISTS

                case "SURVEY_AREA":
                    # Rounding Survey Area to match sensor ranges
                    # print("SENSOR RANGES: " + str(self.sensor_ranges))
                    if len(self.sensor_ranges) > 1:
                        self.gcd = utils.gcd_of_list(self.sensor_ranges)
                    elif len(self.sensor_ranges) == 1:
                        self.gcd = self.sensor_ranges[0]
                    # print("GCD: " + str(self.gcd))

                    self.survey_area = utils.parseSurveyAreaAndCreateObject(msg.string(), self.gcd)
                    self.survey_area_land = utils.parseSurveyAreaAndCreateObject(msg.string(), self.gcd)
                    self.survey_area_land.position = (self.survey_area.position[0] - self.survey_area.width - 100,
                                                      self.survey_area.position[
                                                          1] - self.survey_area.height - 100)  # mirror survey area on both axis

                    # FOR pSEARCHGRID
                    self.x, self.y = self.survey_area.position
                    self.x_edge = self.x + self.survey_area.width
                    self.y_edge = self.y + self.survey_area.height

                    #                                 BOTTOM LEFT                                   BOTTOM RIGHT                                     TOP RIGHT                                    TOP LEFT
                    self.gridMSG = "pts={" + str(self.x) + "," + str(self.y) + ": " + str(self.x_edge) + "," + str(
                        self.y) + ": " + str(self.x_edge) + "," + str(self.y_edge) + ": " + str(self.x) + "," + str(
                        self.y_edge) + "}, cell_size=" + str(
                        self.survey_area.gcd) + ",cell_vars=x:0:y:0,cell_min=x:0,cell_max=x:5,label=psg"

                    print(self.gridMSG)
                    self.comms.notify("VIEW_GRID", self.gridMSG)

                # Mostly for receiving current x,y and heading
                case "NODE_REPORT":
                    vehicle = utils.parseNodeReportAndCreateVehicle(msg.string())
                    if vehicle and vehicle.name in self.available_vehicles:
                        self.available_vehicles[vehicle.name].x = vehicle.position[0]
                        self.available_vehicles[vehicle.name].y = vehicle.position[1]
                        self.available_vehicles[vehicle.name].color = vehicle.color
                        self.available_vehicles[vehicle.name].heading = vehicle.heading
                        print("Updated vehicles:", self.available_vehicles)
                    if vehicle and vehicle.name in self.available_uavs:
                        self.available_uavs[vehicle.name].x = vehicle.position[0]
                        self.available_uavs[vehicle.name].y = vehicle.position[1]
                        self.available_uavs[vehicle.name].color = vehicle.color
                        self.available_uavs[vehicle.name].heading = vehicle.heading
                        print("Updated vehicles:", self.available_vehicles)

                case "STATUS":
                    vehicle_complete = utils.parseStatusAndCreateObject(msg.string())
                    if 'uav' in vehicle_complete.name:
                        if vehicle_complete.name not in self.completed_uavs:
                            if int(vehicle_complete.status) > 2:
                                print(vehicle_complete.name,
                                      " Completed!-------------------------------------------------")
                                self.completed_uavs[vehicle_complete.name] = vehicle_complete
                        if len(self.completed_uavs) == len(self.available_uavs):
                            print("All UAVs finished")
                            # This is where we would run the UUV algorithm
                    if 'vehicle' in vehicle_complete.name:
                        if vehicle_complete.name not in self.completed_uuvs:
                            if int(vehicle_complete.status) > 2:
                                print(vehicle_complete.name,
                                      " Completed!-------------------------------------------------")
                            self.completed_uuvs[vehicle_complete.name] = vehicle_complete
                        if len(self.completed_uavs) == len(self.available_uavs):
                            print("All UUVs finished")



    def assign_waypoints_and_notify_uavs(self):
        # Run if dict not empty
        if self.available_uavs and not self.vehicles_turn:
            # Create a 2d array of 1's for vehicles in survey area. '1' is unassigned space
            height1 = int(self.survey_area.height / self.gcd)
            width1 = int(self.survey_area.width / self.gcd)
            grid_data = np.ones((height1, width1), dtype=int)

            # Offset vehicle positions for algorithm
            for uav in self.available_uavs.values():
                uav.position = (uav.position[0] - self.survey_area.position[0], uav.position[1] - self.survey_area.position[1])

            uav_assignments = generate_assignments(list(self.available_uavs.values()), grid_data, show_graph=True)

            print("UAVs Assignments:", uav_assignments)

            # Notify MOOSDB with the waypoint updates
            for count, (name, assignment) in enumerate(uav_assignments.items()):
                # assignment.reposition();

                points = Points(assignment, self.survey_area.position[0], self.survey_area.position[1])
                waypoints_str = points.string()
                print(f"current vehicle: {name}, waypoints: {waypoints_str} ")
                color = self.available_uavs[name].color
                wpt_var = f"{name}_WPT_UPDATE"
                print(f"SENDING {waypoints_str} to {wpt_var}")
                self.notify(wpt_var, waypoints_str)

                # color = colors[count % len(colors)]  # for waypoint color

                print(f"SENDING {points.string()} to {wpt_var}")

                if len(assignment) == 0:  # No waypoint assigned because survey area is too large
                    print("Waypoint notifications not sent because uav area assignment = 0")
                    self.notify("VIEW_SEGLIST",
                                f'{points.seglist_string()},label={name}_wpt_survey, active=false')  # removes any prior waypoint visuals
                else:
                    self.notify("VIEW_SEGLIST",
                                f'{points.seglist_string()},label={name}_wpt_survey, edge_color={color}, edge_size=2')  # Displays waypoints before deployment
                    self.notify(wpt_var, waypoints_str)





    def assign_waypoints_and_notify_uuvs(self):

        # Create a 2d array based off a preconfigured mission grid layout
        self.grid_height = int(self.survey_area.height / self.gcd)
        self.grid_width = int(self.survey_area.width / self.gcd)
        self.grid_data = ml.resize_mission_layout(ml.mission_area_2, self.grid_width, self.grid_height)

        # Offset vehicle positions for algorithm
        for vehicle in self.available_vehicles.values():
            vehicle.position = (vehicle.position[0] - self.survey_area.position[0], vehicle.position[1] - self.survey_area.position[1])
            print(self.survey_area.position)

        # Assign areas to vehicles using allocation algorithm
        vehicle_assignments = generate_assignments(list(self.available_vehicles.values()), self.grid_data,
                                                   show_graph=True)
        print("Vehicle Assignments:", vehicle_assignments)

        # Notify MOOSDB with the waypoint updates
        for count, (name, assignment) in enumerate(vehicle_assignments.items()):
            # assignment.reposition();
            # color = colors[count % len(colors)]     # for waypoint color
            points = Points(assignment, self.survey_area.position[0], self.survey_area.position[1])
            print(f"current vehicle: {name}, waypoints: {points.string()} ")
            msg_key = f"{name}_WAYPOINTS"
            color = self.available_vehicles[name].color
            wpt_var = f"{name}_WPT_UPDATE"
            print(f"SENDING {points.string()} to {wpt_var}")
            self.notify(wpt_var, points.string())

            if len(assignment) == 0:  # No waypoint assigned because survey area is too large
                print("Waypoint notifications not sent because vehicle area assignment = 0")
                self.notify("VIEW_SEGLIST",
                            f'{points.seglist_string()},label={name}_wpt_survey,active=false')  # removes any prior waypoint visuals
            else:
                self.notify("VIEW_SEGLIST",
                            f'{points.seglist_string()},label={name}_wpt_survey,edge_color={color},edge_size=2')  # Displays waypoints before deployment
                # CHANGE THIS LINE BELOW
                self.notify(wpt_var, points.string())


    # Remove the waypoint information from a list of vehicles
    def unassign_and_notify(self, vehicleList):
        # Notify MOOSDB with empty waypoint updates
        for name, vehicle in vehicleList.items():
            # assignment.reposition();
            waypoints_str = f"points = {vehicle.x},{vehicle.y}"
            wpt_var = f"{name}_WPT_UPDATE"
            print(f"SENDING {waypoints_str} to {wpt_var}")
            self.notify(wpt_var, waypoints_str)


    def visualizeGrid(self, surveyArea, vehicleList):
        surveyArea = surveyArea
        cell_size = self.gcd
        survey_height = surveyArea.height
        survey_width = surveyArea.width
        survey_startX, survey_startY = surveyArea.position
        cell_height = survey_height / cell_size
        # while True:
        # For Each Vehicle

        for name, vehicle in vehicleList.items():
            # Get location and sensor range
            x = vehicle.x
            y = vehicle.y
            head = vehicle.heading
            sensor = vehicle.sensorRange
            sensor_to_grid = int(sensor / cell_size)
            # if in survey
            if x >= survey_startX and x <= (survey_startX + survey_width) and y >= survey_startY and y <= (
                    survey_startY + survey_height):
                grid_x = x - survey_startX
                grid_y = y - survey_startY
                grid_row = int(grid_x / cell_size) + 1
                grid_num = int(grid_x / cell_size) * int(survey_height / cell_size) + int(grid_y / cell_size)
                if grid_num not in self.filled_cells:
                    self.filled_cells.add(grid_num)
                    poke_msg = "psg@" + str(grid_num) + ",x,2"

                    self.notify("VIEW_GRID_DELTA", poke_msg)
                for i in range(0, sensor_to_grid + 1, 1):
                    # if head%90 == 0:
                    # grid_sensor = grid_num + int(i*cell_height)
                    # Cells to left and right of vehicle
                    sensor_right = grid_num + int(i * cell_height)
                    sensor_left = grid_num - int(i * cell_height)
                    if sensor_right not in self.filled_cells:
                        # poke_msg = "psg@" + str(sensor_right) + ",x,5:" + str(sensor_left) + ",x,2"
                        self.filled_cells.add(sensor_right)
                        poke_msg = "psg@" + str(sensor_right) + ",x,2:"
                        self.notify("VIEW_GRID_DELTA", poke_msg)

                    if sensor_left not in self.filled_cells:
                        self.filled_cells.add(sensor_left)
                        poke_msg = "psg@" + str(sensor_left) + ",x,2:"
                        self.notify("VIEW_GRID_DELTA", poke_msg)




# Array of colors that can be used for pMarineViewer geometry. Not a complete list
color_groups = {
    "Red": [
        "coral", "crimson", "hotpink", "palevioletred", "lightpink", "red"
    ],
    "Oranges": [
        "darkorange", "goldenrod", "sandybrown", "lightsalmon", "peachpuff", "tan"
    ],
    "Yellows": [
        "yellow", "gold", "lemonchiffon", "khaki", "lightgoldenrod", "pelegoldenrod"
    ],
    "Greens": [
        "limegreen", "springgreen", "yellowgreen", "forestgreen", "seagreen", "chartreuse"
    ],
    "Blues": [
        "dodgerblue", "deepskyblue", "royalblue", "lightskyblue", "powderblue", "teal"
    ],
    "Purples": [
        "orchid", "violet", "darkviolet", "plum", "indigo", "lavender"
    ],
    "Whites": [
        "floralwhite", "whitesmoke", "ivory", "linen", "seashell", "cornsilk"
    ]
}

colors = [
    'coral', 'dodgerblue', 'crimson', 'deepskyblue', 'hotpink', 'royalblue',
    'red', 'lightskyblue', 'palevioletred', 'powderblue',
    'darkorange', 'sandybrown', 'peachpuff', 'tan',
    'yellow', 'gold', 'lemonchiffon', 'khaki', 'lightgoldenrod', 'pelegoldenrod',
    'limegreen', 'springgreen', 'yellowgreen', 'forestgreen', 'seagreen', 'chartreuse',
    'orchid', 'violet', 'darkviolet', 'plum', 'indigo', 'lavender',
    'floralwhite', 'whitesmoke', 'ivory', 'linen', 'seashell', 'cornsilk'
]

warm_colors = [
    'crimson', 'hotpink', 'red',
    'yellow', 'gold', 'lemonchiffon',
    'lightgoldenrod', 'palegoldenrod'
]

cool_colors = [
    'dodgerblue', 'deepskyblue', 'royalblue',
    'lightskyblue', 'powderblue', 'orchid',
    'violet', 'darkviolet', 'plum', 'indigo', 'lavender'
]
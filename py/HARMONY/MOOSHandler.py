import pymoos
import utils
import AllocationControl

# Class to handle MOOS communication and hold available vehicles and survey area.
class MOOSHandler:

    def __init__(self, host, port, client_name):
        self.comms = pymoos.comms()
        self.host = host
        self.port = port
        self.client_name = client_name
        self.survey_area = None  # Will be set by MOOSMsg sent by user
        self.survey_area_land = None     # Will be set by MOOSMsg sent by user
        self.available_vehicles = {}     # Will be generated by NODE_REPORTs sent by vehicles
        self.available_uavs = {}


    def connect(self):
        # Start connection to MOOSDB and set callback
        self.comms.set_on_connect_callback(self.__on_connect)
        self.comms.run(self.host, self.port, self.client_name)


    def __on_connect(self):
        # Runs after connection
        self.survey_area = None
        self.available_vehicles = {}
        self.register_variables()
        return True


    def register_variables(self):
        # Register for necessary variables
        self.comms.register("NODE_REPORT")  # Needed for current position for each vehicle
        self.comms.register("SURVEY_AREA")  # Sent by a user to define area for vehicles to survey
        self.comms.register("HARMONY_REPORT")   # Sent by user

    def fetch_messages(self):
        # Will return a list of MOOS msg
        return self.comms.fetch()

    def notify(self, variable, value):
        # Send a message to MOOSDB
        self.comms.notify(variable, value, pymoos.time())


    def parse_incoming_messages(self, messages):
        # Input:
        #   A list of MOOS msgs. Usually produced by a fetch.
        #   List of available vehicles.
        #   Survey area
        # Output:
        #   Returns survey area
        #   Adds new vehicles to available vehicles based on NODE_REPORT

        for msg in messages:
            match msg.key():

                case "HARMONY_REPORT":
                    vehicle = utils.parseHarmonyReportAndCreateVehicle(msg.string())
                    if vehicle.type == 'UUV' or 'glider':
                        if vehicle and vehicle.name not in self.available_vehicles:
                            self.available_vehicles[vehicle.name] = vehicle
                            print("Updated vehicles:", self.available_vehicles)
                    # if vehicle.type == 'glider':
                    #     if vehicle and vehicle.name not in self.available_uavs:
                    #         self.available_uavs[vehicle.name] = vehicle
                    #         print("Updated UAVs:", self.available_uavs)

                case "SURVEY_AREA":
                    self.survey_area = utils.parseSurveyAreaAndCreateObject(msg.string())
                    self.survey_area_land = utils.parseSurveyAreaAndCreateObject(msg.string())
                    self.survey_area_land.position = (self.survey_area.position[0] - self.survey_area.width - 100, self.survey_area.position[1] - self.survey_area.height - 100) #mirror survey area on both axis


                # Mostly for receiving current x,y
                case "NODE_REPORT":
                    vehicle = utils.parseNodeReportAndCreateVehicle(msg.string())
                    if vehicle and vehicle.name in self.available_vehicles:
                        self.available_vehicles[vehicle.name].x = vehicle.position[0]
                        self.available_vehicles[vehicle.name].y = vehicle.position[1]
                        self.available_vehicles[vehicle.name].color = vehicle.color
                        #print("Updated vehicles:", self.available_vehicles)




    def assign_and_notify(self):
        # Assign tasks to vehicles and send notifications to MOOSDB
        print(f"{len(self.available_vehicles)} vehicles found. Survey area: {self.survey_area}")
        print(f"{len(self.available_uavs)} uavs found. UAV Survey area: {self.survey_area_land}")

        # Run if dict not empty
        if self.available_vehicles:
            # Assign areas to vehicles using allocation algorithm
            vehicle_assignments = AllocationControl.allocateArea(self.available_vehicles, self.survey_area)
            print("Vehicle Assignments:", vehicle_assignments)

            # Notify MOOSDB with the waypoint updates
            for count, (name, assignment) in enumerate(vehicle_assignments.items()):
                assignment.reposition();
                # color = colors[count % len(colors)]     # for waypoint color
                color = self.available_vehicles[name].color
                wpt_var = f"{name}_WPT_UPDATE"
                print(f"SENDING {assignment.string()} to {wpt_var}")

                if assignment.width == 0:     # No waypoint assigned because survey area is too large
                    print("Waypoint notifications not sent because vehicle area assignment = 0")
                    self.notify("VIEW_SEGLIST", f'{assignment.string()},label={name}_wpt_survey, active=false')  # removes any prior waypoint visuals
                else:
                    self.notify("VIEW_SEGLIST", f'{assignment.string()},label={name}_wpt_survey, edge_color={color}, edge_size=2')  # Displays waypoints before deployment
                    self.notify(wpt_var, assignment.string())

    # ------------------------------------------------------

        # Run if dict not empty
        if self.available_uavs:
            # Assign areas to uavs using allocation algorithm
            uav_assignments = AllocationControl.allocateArea(self.available_uavs, self.survey_area_land)
            print("UAVs Assignments:", uav_assignments)

            # Notify MOOSDB with the waypoint updates
            for count, (name, assignment) in enumerate(uav_assignments.items()):
                assignment.reposition();


                # color = colors[count % len(colors)]  # for waypoint color

                if "uav" in name:
                    color = warm_colors[count % len(warm_colors)]
                elif "vehicle" in name:
                    color = cool_colors[count % len(cool_colors)]

                wpt_var = f"{name}_WPT_UPDATE"
                print(f"SENDING {assignment.string()} to {wpt_var}")

                if assignment.width == 0:  # No waypoint assigned because survey area is too large
                    print("Waypoint notifications not sent because uav area assignment = 0")
                    self.notify("VIEW_SEGLIST",
                                f'{assignment.string()},label={name}_wpt_survey, active=false')  # removes any prior waypoint visuals
                else:
                    self.notify("VIEW_SEGLIST",
                                f'{assignment.string()},label={name}_wpt_survey, edge_color={color}, edge_size=2')  # Displays waypoints before deployment
                    self.notify(wpt_var, assignment.string())




# Array of colors that can be used for pMarineViewer geometry. Not a complete list
color_groups = {
    "Red": [
        "coral", "crimson", "hotpink", "palevioletred", "lightpink", "red"
    ],
    "Oranges": [
        "darkorange", "goldenrod", "sandybrown", "lightsalmon", "peachpuff", "tan"
    ],
    "Yellows": [
        "yellow", "gold", "lemonchiffon", "khaki", "lightgoldenrod", "pelegoldenrod"
    ],
    "Greens": [
        "limegreen", "springgreen", "yellowgreen", "forestgreen", "seagreen", "chartreuse"
    ],
    "Blues": [
        "dodgerblue", "deepskyblue", "royalblue", "lightskyblue", "powderblue", "teal"
    ],
    "Purples": [
        "orchid", "violet", "darkviolet", "plum", "indigo", "lavender"
    ],
    "Whites": [
        "floralwhite", "whitesmoke", "ivory", "linen", "seashell", "cornsilk"
    ]
}

colors = [
    'coral', 'dodgerblue', 'crimson', 'deepskyblue', 'hotpink', 'royalblue',
    'red', 'lightskyblue', 'palevioletred', 'powderblue',
    'darkorange', 'sandybrown', 'peachpuff', 'tan',
    'yellow', 'gold', 'lemonchiffon', 'khaki', 'lightgoldenrod', 'pelegoldenrod',
    'limegreen', 'springgreen', 'yellowgreen', 'forestgreen', 'seagreen', 'chartreuse',
    'orchid', 'violet', 'darkviolet', 'plum', 'indigo', 'lavender',
    'floralwhite', 'whitesmoke', 'ivory', 'linen', 'seashell', 'cornsilk'
]

warm_colors = [
    'crimson', 'hotpink', 'red',
    'yellow', 'gold', 'lemonchiffon',
    'lightgoldenrod', 'palegoldenrod'
]

cool_colors = [
    'dodgerblue', 'deepskyblue', 'royalblue',
    'lightskyblue', 'powderblue', 'orchid',
    'violet', 'darkviolet', 'plum', 'indigo', 'lavender'
]
